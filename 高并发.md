[高并发与高性能](http://www.52im.net/thread-3272-1-1.html)
> 暂时忽略Procator和信号驱动式IO、异步IO模型.

# 一、线程与线程池
### 为什么线程的入口需要函数?
* 进程的入口是main函数, 但若想让线程作为执行的基本单位, 则一个进程内可以有多个入口函数, 也就是把CPU的PC寄存器指向线程的入口函数，这样线程就可以运行起来了，这就是为什么我们创建线程时必须指定一个入口函数的原因.

### 既然有多个线程, 则维护线程的栈必然也是放在进程的内存中.
![进程栈空间](https://github.com/zpeng1997/Advanced/blob/master/picture/进程栈空间.png)

* 首先因为共享进程的内存空间.
* 维护每个线程的栈, 必然在进程中.

### 线程的使用分类
* 长任务: 类似word写磁盘的任务.
* 短任务: 类似server的, 网络一次请求, 数据库的一次查询. 特点: 任务时间短, 数量巨大.

### 怎么处理 短任务 数量巨大的问题?
* 1.任务处理完了就直接销毁即可? ==> thread per request.
* 2.缺点? 这种对于长任务比较好, 但是对于短任务, 
* 首先, 线程的创建和销毁需要时间, 其次大量的线程需要 栈空间, 导致空间不足.

### 如何解决thread per request的问题? ==> 线程池.
* 避免频繁的创建和销毁进程, 创建特定的进程之后, 不再释放, 一般而言线程池中的数量一定.

### 如何把任务给到线程池中的线程?
* 经典的生产者-消费者模型
* (核心功能)首先线程阻塞在队列上, 当有任务时, 线程会被唤醒, 线程从队列上取出结构体, 然后调用函数.

### 如何确定线程池的数量？
* 前面从生命周期的角度我们把线程分为: 短任务 和 长任务.
* 因为线程的数量和是否有效利用CPU资源和内存占用(过多,系统性能下降)有关.
* CPU密集型 和 IO密集型(磁盘IO、网络IO): 
* CPU密集型: 例如矩阵运算、科学计算等, 线程池的数量和CPU的核数相同即可.
* IO密集型: 性能测试工具测试出IO等待的时间WT(wait time), 以及CPU计算所需要的时间CT(computing time), 对于N核的系统, 合适的数量应该是N*(1 + WT/CT), 
* 充分利用CPU不是唯一需要考虑的点, 随着线程的增多, 内存增多, 系统调用, 文件打开, 打开的socket的数量, 打开的数据库连接的数量等等都是需要考虑的.

### 线程池只是多线程的一种使用形式, 多线程面临的问题线程池同样不能避免.
* 死锁问题, race condition问题

### 线程池的最佳实践
* 确定任务类型: 长/短任务, CPU/IO密集型任务. 若两者都有, 可以尝试把两者放到不同的线程池.
* 若有IO操作, 设计对任务设置超时, 否则可能一直会阻塞下去.
* 线程池中的任务最好不要同步等待其它任务的结果.


# 二、IO
### 什么是IO?
* 图形界面, 鼠标, 键盘, 文件读写, 网络IO, 等等一切... 都是IO.
* IO是数据简单的Copy: 磁盘--内存, 网卡--内存, 屏幕--内存.
* CPU和IO速度差异巨大? 必然CPU需要等待(此时的IO是 Blocking IO阻塞式IO).
* 如何等待? --> 阻塞进程.
* 进程放到-->阻塞队列(记录状态和PC), 磁盘这时把数据copy到系统内存再到该进程的buff中(用的DMA,不需要CPU的参与), 
* 磁盘数据copy到该进程的buff完毕, --> 中断 --> 操作系统将其进程放入-->就绪队列(僧多粥少, CPU有限).
* 当然此时进程A刚刚放入就绪队列, 可能已经有一个进程B执行了一个时间片, 则进程B放入就绪队列, 进程A拿出执行.

### 零拷贝Zero Copy
* 因为数据是通过 设备 --> 操作系统 --> 进程空间
* 对于性能要求很高的场景, 需要跳过中间一步, 这就叫做Zero Copy.

### Epoll为什么比select快?
* Select 是对fd轮询, 每次轮询完之后需要把fd数组清空(置位), 然后再次轮询.
* Poll中fd是个结构体, struct pollfd{int fd, short events, short revents}; 是对pollfd中的events和revents置位, 而不是对fd本身, 而且不依赖bitmap, 使用的是pollfd结构体, 故数量没有限制.
* Epoll相对于Select和Poll的区别就是, 在select和poll中，如果某个请求的数据已经准备好，它们会将所有的请求都返回，供程序去遍历查看哪个请求存在数据，但是epoll只会返回存在数据的请求，这是因为epoll在发现某个请求存在数据时，首先会进行一个重排操作，将所有有数据的fd放到最前面的位置，然后返回（返回值为存在数据请求的个数N），那么我们的上层程序就可以不必将所有请求都轮询，而是直接遍历epoll返回的前N个请求，这些请求都是有数据的请求。
* Epoll和上述两个函数最大的不同是，它的fd是共享在用户态和内核态之间的，所以可以不必进行从用户态到内核态的一个拷贝，这样可以节约系统资源。也是它快的一个重要点.
* Epoll 相比较于 Select 和 Poll 另一个优势是 Epoll基于事件驱动; Select和Poll机制下进程亲自取各个文件描述符等待, 当有文件描述符可读或者可写, 则唤醒进程; Epoll机制, 进程只是在epoll_wait()上等待, 而Epoll本身去各个文件描述符等待并记录准备好的文件描述符, 最后唤醒进程, 并且把可读或者可写的文件描述符给进程.

### select的缺点：
* 底层存储依赖bitmap，处理的请求是有上限的，为1024
* 文件描述符是会置位的，所以如果当被置位的文件描述符需要重新使用时，是需要重新赋空值的
* fd（文件描述符）从用户态拷贝到内核态仍然有一笔开销
* select返回后还要再次遍历，来获知是哪一个请求有数据

### 阻塞IO与非阻塞IO和IO复用的区别?
* 阻塞IO这个很熟悉, recvfrom等待数据准备好的时候一直的阻塞的(底层传数据给内核再到进程)---> 类似中断
* 非阻塞IO, 只是传入参数告诉内核不要阻塞我的进程, 但是需要一直轮询 ---> 类似轮询
* IO复用, 也存在阻塞, 而且是两次.
* 第一次Select/Epoll没有查询到有数据请求时一直是阻塞的.
* 第二次有数据调用后才真正执行IO函数, IO函数recvfrom本身是阻塞的. 
* 相对于阻塞IO的优点, 阻塞IO中每个文件描述符对应一个进程, 每次每个进程都会阻塞; 而复用是IO中用一个对象(进程)来处理所有的文件描述符, 也只是阻塞一个进程, 其它的进程可以处理连接或者业务逻辑等等其它的事情. 
* 缺点: 当连接数较少时, 发挥不出它的优势, 可能会比阻塞IO还要差.

### 非阻塞IO有什么用呢?
* (错误)因为不会阻塞线程, 那么对于多线程的非阻塞IO, 不会因为一个线程的阻塞导致整个进程内所有的线程全部都阻塞, 可以用来实现线程级别的 I/O 并发, 与通过多进程实现的 I/O 并发相比可以
减少内存消耗以及进程切换的开销。
* Linux内部线程是一对一模型, 一个线程的阻塞不会导致其它线程阻塞.
* 同理, 异步也是如此.

### 如果是这样的话, 那么应该是单独一个 进程处理select 然后把结果发回给 其worker线程池中的线程..... 看看代码 验证自己的理解.
[再理解Netty是如何实现Reactor+IO复用模型的](http://www.52im.net/thread-2043-1-1.html)


### 同步和异步在不同层面(底层IO和整个框架)的理解.
* epoll只是一个通知的机制,但是取数据这个动作本身,还是要程序自己主动去调用recv之类的函数的.所以我们讲,这是一个同步IO.
* 就像描述车速的迈与码一样，异步这个词也被慢慢曲解。举个例子，我搜的所有文章都在说nginx是异步非阻塞，nginx的事件机制使用epoll，按UNP定义，它是同步的，我觉得之所以说nginx是异步，是指它处理请求时通过事件机制使得各个请求可以处在不同阶段以不同步调执行，所以这里的异步跟书本上定义的异步是不一样的。

### 一切皆文件的强大之处
* Socket、Named Pipe也被看成文件
* 也就是说open(), seek(), read(), write(), close()这些可以实现几乎所有IO操作
* 包括网络IO和设备IO
![一切皆文件](https://github.com/zpeng1997/Advanced/blob/master/picture/一切皆文件.png)


### 文件? 文件描述符?
* 函数如何找到文件(因为有屏幕、磁盘等等各种各样的)==>只需要数字-->文件描述符
* int fd = open(file_name), read(fd, buff); 从fd代表的文件中写入到buff中.
* 当服务器accept一个连接后, 我们也会有一个文件描述符, int conn_fd = accept(...), 服务器Server之后的一般逻辑是将信息转发, if(read(conn_fd, msg_buff)>0) do_trans(msg_buff);


### 高并发
* 服务器需要和成千上万个Client连接通信, 那就需要处理成千上万个文件描述符. 如何做?

```C++
// 方案一:
if(read(socket_fd1, msg_buff)>0){ // 处理第一个
    do_trans(msg_buff);
}
if(read(socket_fd2, msg_buff)>0){ // 处理第二个
    do_trans(msg_buff);
}
// 显然这是经典的阻塞式IO, 第一个阻塞了, 第二个无法处理
// 解决方案1: 为每个Client开一个线程?
// 成千上万个线程必然消耗系统性能, 不能高并发.
// 关键点: 我们不知道每个网络IO是否可读? 可写? 在外设不可读或写的情况下IO操作只会被阻塞
// 如何解决这个问题?
// 把所有的文件描述符全部扔给内核, 当有文件描述符可读或者可写时, 让内核告诉我.
// 这就是IO多路复用(IO Multiplexing)
```

### IO多路复用过程
* 我们拿到了一堆文件描述符（不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以）
* 通过调用某个函数告诉内核：“这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回”；
* 当调用的这个函数返回后我们就能知道哪些文件描述符可以进行I/O操作了。
* IO多路复用名词常见于通信领域
![IO多路复用](https://github.com/zpeng1997/Advanced/blob/master/picture/IO多路复用.png)


### 同步与异步
* 同步调用: 好理解, 且无法同时进行
```C++
funcA() {
    // 等待函数funcB执行完成
    funcB();
     
    // 继续接下来的流程
}
```
* 异步调用: 异步调用总是和I/O操作等耗时较高的任务如影随形，像磁盘文件读写、网络数据的收发、数据库操作等。
```C++
//异步调用的高效点在于: 可以同时执行
//异步调用下调用方怎知道被调函数是否执行完成呢？
//两种情况:
//1.调用方根本就不关心执行结果；
//2.调用方需要知道执行结果。
//第一种情况比较简单，无需讨论。
//第二种情况下就比较有趣了，通常有两种实现方式
//(1) 一种是通知机制：
//当任务执行完成后发送信号来通知调用方任务完成（这里的信号有很多实现方式：Linux中的signal，或使用信号量等机制都可实现）
//(2) 一种是回调机制
//也就是我们常说的callback
```

### 异步的实现例子.
* 一般来说Web Server接收到用户请求后会有一些典型的处理逻辑，最常见的就是数据库查询（当然，你也可以把这里的数据库查询换成其它I/O操作，比如磁盘读取、网络通信等），在这里我们假定处理一次用户请求需要经过步骤A、B、C，然后读取数据库，数据库读取完成后需要经过步骤D、E、F。
```
//处理一次用户请求需要经过的步骤：
A;
B;
C;
//数据库读取;
D；
E；
F；
// A~C和D~F都不需要读取文件、网络通信等, 只有数据库读取这一步涉及到IO操作.
```
* 这样的Web Server有两个典型的线程：主线程和数据库处理线程（注意：这讨论的只是典型的场景，具体业务实际上可会有差别，但这并不影响我们用两个线程来说明问题）
```C++
// 主线程
main_thread() {
    A;
    B;
    C;
    发送数据库查询请求;
    D;
    E;
    F;
}
// 数据库线程
DataBase_thread() {
    while(1) {
        处理数据库读取请求;
        返回结果;
    }
}
```
* 异步情况1：主线程不关心数据库操作结果: 在这种情况下，主线程根本就不关心数据库是否查询完毕，数据库查询完毕后自行处理接下来的D、E、F三个步骤。
* 我们说过一个请求需要经过七个步骤，其中前三个是在主线程中完成的，后四个是在数据库线程中完成的，那么数据库线程是怎么知道查完数据库后要处理D、E、F这几个步骤呢？
```C++
// 没错，回调函数就是用来解决这一问题的。
// 我们可以将处理D、E、F这几个步骤封装到一个函数中，假定将该函数命名为handle_DEF_after_DB_query。
void handle_DEF_after_DB_query () {
    D;
    E;
    F;
}
//这样主线程在发送数据库查询请求的同时将该函数一并当做参数传递过去：
DB_query(request, handle_DEF_after_DB_query);
//数据库线程需要做的仅仅就是查询数据库、然后调用一个处理函数，至于这个处理函数做了些什么数据库线程根本就不关心，也不应该关心。
//你可以传入各种各样的回调函数：也就是说数据库系统可以针对回调函数这一抽象的函数变量来编程，从而更好的应对变化，因为回调函数的内容改变不会影响到数据库线程的逻辑，而如果数据库线程自己定义处理函数那么这种设计就没有灵活性可言了。
//这样复杂数据库的团队就和使用方团队实现了所谓的解耦。
```
* 异步情况2：主线程关心数据库操作结果
![异步处理情况2](https://github.com/zpeng1997/Advanced/blob/master/picture/异步处理情况2.png)
```C++
//在这种情况下，数据库线程需要将查询结果利用通知机制发送给主线程，主线程在接收到消息后继续处理上一个请求的后半部分。
//ABCDEF几个步骤全部在主线中处理，同时主线程同样也没有了“休闲时光”，只不过在这种情况下数据库线程是比较清闲的，从这里并没有上一种方法高效，但是依然要比同步模式下要高效。
//注意: 并不是所有的情况下异步都一定比同步高效，还需要结合具体业务以及IO的复杂度具体情况具体分析。

// 其实并不是很好理解这一块, 或者说没找到例子
// 这里是猜测?
// 也是利用回调函数, 但是这里的回调函数是主线程自己的, 当通知机制通知时, 自动执行该函数
```

### 协程: 开源libco库：单机千万连接、支撑微信8亿用户的后台框架基石
