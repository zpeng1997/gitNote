## 0.MySQL 知识框架分为如下:
- 1.mysql框架介绍
- 2.索引优化分析
- 3.查询截取分析
- 4.主从复制
- 5.MySql锁机制

## 1.MySQL的基础架构: 一条SQL查询语句是如何执行的？
客户端 -->  连接器 ---> 查询缓存                       |   存储引擎
              |______> 分析器| --> 优化器 ---> 执行器  |   存储引擎 
            |------------- server层 ----------------- |---- 存储引擎层 ----|
- 大体分为Server层 和 存储引擎层
    - Server层负责: 存储过程, 触发器, 视图. 
    - 存储引擎层负责数据的存储提取, 其架构模式是插件式的, 指出InnoDB
    MYISAM, Memory 等多个存储引擎.(现在最常用的是InnoDB引擎)

- 连接器:
    - 链接通过, 连接器会回到权限表查出该用户拥有的权限(以后都依赖此时读到的权限); 即使管理员修改用户的权限, 对于本次不起作用, 对于下一次新链接才有用.
    - 链接完成后, 没有后续动作, 这个连接处于空闲状态, 可以通过show processlist查看, 其中Command列中显示Sleep的这一行, 就表示现在系统里面有一个空闲链接. 
    - wait_timeout时间: 8个小时, 连接断开后会收到错误提醒: lost connection to mysql server during query.
    - 长连接(占用内存多) 与 短连接(连接的过程比较复杂)
        - 可以定期断开长连接, 或者在程序里执行过占用内存的大查询后, 断开连接, 之后要查询再重连.
        - mysql5.7或者更新版本, 执行比较大的操作后, 执行mysql_reset_connection重新初始化资源, 这个过程不需要重连和权限认证, 但是会恢复到刚刚创建完成的状态.   

- 查询缓存:
    - 查询缓存弊大于利? 查询缓存的失效非常频繁, 只要对一个表更新, 这个表上所有的查询缓存都会被清空, 因此很可能还没使用就是失效了. 所以对于更新压力大的数据库而言, 查询缓存的命中率很低, 除非有业务有静态表, 很长时间才更新一次, 比如系统配置表.
    - MySQL提供按需使用的方式, 参数为query_cache_type=demand. 这样默认sql语句不使用, 对于要使用查询缓存的语句, 可以显示的使用sql_cache.
    - select SQL_CACHE * from T where ID=10, mysql 8.0版本已经将查询缓存功能删除.

- 分析器: 词法分析, 语法分析.
- 优化器: 表中有多个索引的时候,决定使用哪个索引; 或者在一个语句有多个表关联join的时候, 决定各个表的链接顺序. 
    - select * from t1 join t2 using (ID) where t1.c=10 and t2.d=20;
        - 1. 先从表t1取出c=10的值, 再根据id值关联表t2, 再判断t2里面的d是否=20
        - 2. 同理.
        - 优化器的作用是决定选择使用哪一个方案.
    - 面试题: 那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？
        - 1、根据搜索条件，找出所有可能使用的索引 
        - 2、计算全表扫描的代价 
        - 3、计算使用不同索引执行查询的代价 
        - 4、对比各种执行方案的代价，找出成本最低的那一个
    - 那排查的时候，有什么手段可以知道有没有走索引查询呢？
        - 可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况 
- 执行器: 
    - 判断对这个表t是否有执行查询的权限, 如果没有, 返回没有权限的错误.
    - 有权限, 打开表执行, 打开表的时候, 执行器会根据表的引擎定义, 使用引擎提供的接口. 
        - (1)若表t , id字段没有index, 那么执行器的执行流程:
            - 1. 调用innodb引擎接口取这个表的第一行, 判断id值是否=10, 如果不则跳过, 如果是则将这些行缓存在 结果集 里面.
            - 2. 调用引擎接口取“下一行”, 重复相同的逻辑, 一直取到这个表的最后一行.
            - 3. 执行器将上述遍历过程中所有满足条件的行组成 记录集 作为 结果集 返回给客户端.
        - (2)若存在index的表:
            - 1. 直接取出 满足这个条件的 第一行, 之后 同理 取下一行...
    - 数据库的 慢查询日志 中看到一个rows_examined的字段, 表示这个语句执行过程中扫描了多少行. 这个值就是在执行每次调用引擎获取数据行的时候累加的.
    - 有些场景, 执行器调用一次, 在引擎内部扫描多行, 所以引擎扫描行数和row_examined(引擎的调用次数)并不是完全相同.

- 存储引擎层:  
    - 支持: InnoDB, Memory, MyISAM等
    - create table语句中使用engine=memory, 可以指定使用的存储引擎。

## 2.日志系统: 一条SQL更新语句是如何执行的？
- redo log(重做日志, InnoDB的日志) 和 binlog (归档日志, server的日志)
    - redo log: 一条更新语句, InnoDB引擎就是先把记录写到redo log, 并更新内存.适当的时候, InnoDB会将这个操作记录更新到磁盘里面(空闲的时候做).
        - redo log 是固定大小, 比如配置一组4个文件, 每个文件大小1GB, 总共4GB. (写到尾部后从头开始写)
        - 这叫做WAL技术: Write-Ahead Logging, 先写日志, 再写磁盘, 等不忙的时候再写账本.
        - 有了redo log, InnoDB就可以保证即使数据库发生异常重启, 之前提交的记录都不会丢失, 这个能力叫做crash-safe.
        - innode_flush_log_at_trx_commit这个参数设置为1的时候, 表示每次事务的redo log都直接持久化到磁盘(建议这么做).
    - binlog: Server层自己的日志.
        - 因为最开始MySQL里并没有InnoDB引擎, MySQL自带的是MyISAM,但是MyISAM没有crash-safe的能力, binlog只能用于归档. InnoDB是另一个公式以插件形式引入MySQL的.
        - sync_binlog这个参数设置为1的时候, 表示每次事务的binlog都持久化到磁盘.
        - binlog 有两种模式, statement格式是记录sql语句, row格式会记录行的内容, 记录两条, 更新前和更新后都有.
- 不同点:
    - (1.特有与通用)redo log是InnoDB引擎特有的, binlog是所有MySQL的Server层实现的, 所有引擎都可以使用.
    - (2.物理与逻辑)redo log是物理日志, 记录的是"在某个数据页上做了什么修改"; binlog是逻辑日志, 记录的是这个语句的原始逻辑, 比如"给ID=2的这一行的c字段加1". 一个底层, 一个Server层, 比较好理解.
    - (3.有限大小与无限大小)redo log是循环写的, 空间固定会用完; binlog 是可以追加写入的, 也就是binlog写到一定大小后会切换到下一个, 不会覆盖以前的日志.
- 具体的操作流程:
    - 1. 执行器先找引擎去ID=2这一行, ID是主键, 引擎直接用树搜索找到这一行, 如果ID=2所在数据页本来就在内存中, 就直接返回给执行器; 否则, 需要先从磁盘读入内存, 然后再返回.
    - 2. 执行器拿到引擎给的行数据, 把这个值加上1, 得到新的一行数据, 再调用引擎接口写入这行新数据.
    - 3. 引擎将这行新数据更新到内存中, 同时将更新操作记录到redo log里面, 此时redo log处于prepare状态, 然后告知执行器执行完成了, 随时可以提交事务.
    - 4. 执行器生成这个操作的binlog, 并把binlog写入磁盘.
    - 5. 执行器调用引擎的提交事务接口, 引擎把刚刚写入的redo log改成提交commit状态, 更新完成.
    - redo log两阶段提交, prepare 和 commit中间有 binlog的写入, 不然会导致 数据库状态和用它的日志恢复出来的库的状态不一致.
        - 如果是提交事务的时候正好重启那么redo log处于prepare状态, binlog已经接受, 在崩溃恢复过程会认可这个事务, 提交掉.

- 如何让数据库恢复到半个月内任意一秒的状态?
    - binlog记录所有的逻辑操作, 同时系统会做定期整库备份, 时间的长短取决于系统的重要性, 可以是一天一备, 也可以是一周一备.
        - 假设中午十二点又一次误删表, 可以找回最近一次全量备份, 从备份点开始将备份binlog依次取出来, 重放到中午误删表之前的那个时刻. 这样你可以把表数据从临时库中取出, 按照需要恢复到线上库去.
        - 而且对于需要多搭建一些备库增加系统的读能力, 常见做法也是全量备份加上binlog, 如果不是 两阶段提交 也会导致主从数据库的不一致.

## 3.事物隔离: 为什么你改了我还看不见?
- 事务: 一系列操作要么成功要么不成功.
- MySQL中事务支持是在引擎层实现的, MySQL中是支持多引擎的系统, 但并不是所有的引擎都支持事务, 原生MyISAM引擎就不支持事务, 也是MyISAM被InnoDB取代的重要原因.
- 四个性质: ACID
    - 隔离性 Isolation
    - 持久性 Durability
    - 原子性 Atomicity
    - 一致性 Consistency
- 四种隔离级别: Reasons: dirty read, non-repeatable read, phantom read
    - Read Uncommited 读取未提交内容 : 没提交就可以被其它事务看到.
    - Read Commited 读取提交内容 : 提交后, 它所做的变更才能被其它事务看到.
    - Repeatable Read 可重读(默认) :  
    - Serializable 可串行化 : 通过读锁 和 写锁, 读写锁冲突时, 后访问的事务必须等待前一个.
    - 总结: 隔离的越严实, 效率就会越低, 因此很多时候我们需要在二者之间找到一个平衡点.

### 4.主要流程如下:
事务A|事务B
--|:--:
启动事务A查询得到值1| 启动事务
- |查询得到值1
- |将1改为2
查询得到值V1 | -
- | 提交事务B
查询得到值V2 | - 
提交事务A | - 
查询得到值V3 | -

- Read Uncommited: V1的值是2, 事务B虽然没有提交, 但是A看到了, V2, V3也是 2
- Read Commited: V1是1, V2, V3是 2
- Repeatable Read: 则V1, V2是1, V3是2; V1 和 V2都是在事务A执行期间, 所以看到的数据要求一致.
- Serializable: 事务B在执行"将1改为2"时候, 会被锁住, 知道事务A执行完毕之后, 从事务A的角度看: V1 和 V2值是1, V3的值是2.
- 实现方式, 创建视图:
    - Repeatable Read: 事务启动时创建视图, 整个事务存在期间都是用这个视图.
        - 应用场景: 数据校对逻辑. 新来的一笔交易不影响校对.
        - 实现方式: 每条记录的更新会同时记录一条回滚操作. 一条记录在系统可以存在多个版本, 就是数据库的多版本并发控制(MVCC). 回滚日志在系统中没有比这更早的read-view时会删除.
        - MySQL5.5以及以前的版本, 回滚日志是跟数据字典一起放在ibdata文件里的, 即使长事务最终提交, 回滚段被处理, 文件也不会变小. 见过数据只有20GB, 而回滚段有200GB的库. 而且长事务还占用锁资源.
    - Read Commited: 视图是在每个SQL语句开始执行的时候创建的.
    - Read Uncommited: 没有视图的概念, 直接返回记录上最新值.
    - Serializable:  直接加锁的方式避免并行访问.
- Oracle数据库的默认隔离级别是“读提交”, 因此对于一些从Oracle迁移到MySQL的应用, 为了保证数据库隔离级别一致, MySQL的隔离级别也要设置为“读提交”.
```C++
show variables like 'transaction_isolation'; // 查看当前的 隔离级别
```

## 5.事务的启动方式:
- 显示启动事务语句: begin 或 start transcaction。配套的提交语句是commit, 回滚语句是rollback。
- set autocommit=0, 会把线程的自动提交关闭。事务启动后, 并不会自动提交, 一直持续到主动执行commit 和 rollback语句, 或者断开连接.
    - 推荐使用set autocommit=1显示语句启动事务, 用begin显示启动的事务, 如果commit则提交事务, 如果执行commit work and chain, 则是提交事务并自动启动下一个事务, 这样也省去了再次执行begin语句的开销. 同时从程序开发的角度明确知道每个语句是否处于事务中. 
    - 可以在information_schema库的innodb_trx这个表中查询长事务
    - select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

## 6.索引
- 哈希表: 只适用于等待查询的场景(Memcached以及其他一些NoSQL引擎)。因为不是有序的, 区间查询很慢.
    - B+ Tree索引和Hash索引区别？
    - 哈希索引适合等值查询，但是无法进行范围查询
    - 哈希索引没办法利用索引完成排序 
    - 哈希索引不支持多列联合索引的最左匹配规则
    - 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题
- 有序数组索引: 只适用于静态存储引擎(不会再修改), 在等值查询和范围查询中表现很优秀.
- 搜索树:
- 跳表, LSM树 等数据机构也被用于引擎设计中.[LSM介绍](https://www.zhihu.com/question/19887265)
- MySQL中, 索引都是在存储引擎层实现的. 不同的存储引擎的索引的工作方式并不一样. 即使多个存储引擎支持同一种类型的索引, 其底层的实现也不能不同. 
- InnoDB的索引模型: 一个索引在InnoDB中对应一棵B+树
    - 主键索引(整行数据, 聚簇索引) 和 非主键索引(主键的值, 二级索引)
    - `` create table T(id int primary key, k int not null, name varchar(16), index (k)) engine=InnoDB; ``
    - diff?
        - 主键索引:  select * from where ID=500, 搜索ID这个B+树
        - 非主键索引: select * from where k=5, 先搜索k索引树, 得到ID=500,再搜索ID索引树搜索一次, 这个过程称为回表.
        - 所以说基于非主键索引的查询需要多扫描一个索引树, 所以尽量使用主键查询.
        - 自增主键: NOT NULL PRIMARY KEY AUTO_INCREMENT
            - 插入可能导致页分裂, 性能肯定会有影响. 空间利用率降低.
            - 可以不指定ID的值,系统会获取当前ID最大值加1作为下一条记录的ID值.(追加的方式,不会触发叶子结点的分裂.) 而用业务逻辑的字段做主键, 往往不容易保证有序的插入, 这样写数据成本相对较高.
            - 如果用身份证号作为主键呢? 由于每个非主键所以的叶子节点上都是主键的值, 如果用身份证号做主键, 那么每个二级索引的叶子结点占用约为20字节, 如果用整形做主键, 只要4个字节, 长整型则是8个字节.
        - 当有的业务场景是只有一个索引,该索引必须是唯一索引. 经典KV场景.
        - 重建索引k: `` alter table T drop index k; alter table T add index(k); `` 
        - 重建主键索引: `` alter table T drop primary key; alter table T add primary key(id); `` 这样会导致 普通索引 失效. 
        - `` alter table T engine=InnoDB ``
    - 覆盖索引:
        - select ID from T where between 3 and 6, 这时只需要查ID的值, 而ID的值已经在k索引树上, 所以可以直接提供查询结果, 不需要回表. 也就是, 查询里面, 索引k已经覆盖了我们查询需求, 覆盖索引.
        - 覆盖索引是一个常用的性能优化手段(最左前缀原则), B+树的区间查询。
        - 索引的复用能力: 因为可以支持最左前缀, (a,b)联合索引, 一般不需要单独在a上建立索引.
    - 联合索引: 当已经有了(a, b)这个联合索引后, 一般就不需要单独在a上建立索引了. 第一原则就是, 如果通过调整顺序, 可以少维护一个索引, 那么这个顺序是需要优先考虑采用的. 创建了(key1, key2, key3) 相当于创建了(key1), (key1, key2) 和 (key1, key2, key3).
    - 索引下推: MySQL5.6之后有, 在最左前缀的基础上, 筛选不符合的索引. 比如: age = 10, 这样就减少了回表的次数.
- 什么情况下会使索引失效？
    - 避免使用关键字：or ，in，not in ，!=，<>，避免使用select *
        - 避免在where子句中使用or来连接条件,因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描。SELECT id FROM table WHERE num = 0 OR num = 1
        - 避免在where子句中使用int关于网上说的MySQL在使用int不走索引的问题,严谨的来说的话分为俩种情况
            - 走索引:`` SELECT id FROM table WHERE num IN (1) ``
            - 不走索引:`` SELECT id FROM table WHERE num IN (1) ``
    - 尽量避免子查询，大部分子查询都可以连接查询
    - 用到or的地方可以使用union去代替实现
    - 用到in的地方可以使用exists去代替
    - 避免在where子句中=的左边使用表达式操作或者函数操作
        - ``SELECT id FROM table WHERE num / 2 = 1``
        - ``SELECT id FROM table WHERE SUBSTRING(name,1,2) = 'wise'``
    - 避免在where子句中使用like模糊查询
        - `` SELECT id FROM table WHERE name LIKE 'wise'``
    - 在使用联合索引是要注意最左原则,例如如果当前联合索引是index(a,b,c),那么如果where子句中有a就会用到联合索引,但是如果只用到b,c就会失去索引效果
        - `` SELECT id FROM table WHERE name LIKE 'wise' ``
- 问题:
```C++
CREATE TABLE 'geek'(
    'a' int(11) NOT NULL,
    'b' int(11) NOT NULL,
    'c' int(11) NOT NULL,
    'd' int(11) NOT NULL,
    PRIMARY KEY ('a','b'), // a, b做联合主键
    KEY 'ca' ('c','a'),
    KEY 'cb' ('c','b')
) ENGINE=InnoDB;
// 历史原因, 这个表a, b做联合主键 
// 因为历史原因, 需要“ca“, "cb"这两个索引, 但是因为有联合主键, 那么再加上一个索引c, 就包含三个字段了呀
select ... from geek where c=N order by a;
select ... from geek where c=N order by b;
// 请问是否ca, cb都是必须的

// a, b联合主键, 索引组织顺序相当于order by a, b 也就是先按a排序, 再按 b 排序, c无序
-a--|-b--|-c--|-d--
1     2    3    d
1     3    2    d
1     4    3    d
2     1    3    d
2     2    2    d
2     3    4    d

//索引c, a的组织是先按c排序, 再按a排序, 同时记录主键
-c--|-a--|-主键部分b-- (注意, 这里不是ab, 而是只有b)
2     1      3
2     2      2
3     1      2
3     1      4
3     2      1
4     2      3
// 这和索引c的数据是一模一样的

//索引c,b的组织是先按c排序, 再按b排序, 同时记录主键
-c--|-a--|-主键部分a-- (注意, 这里不是ab, 而是只有a)
2     2      2
2     3      1
3     1      2
3     2      1
3     4      1
4     3      2
// 所以去掉ca, 保留cb
```



## 7.全局锁和表锁: 给表加个字段怎么有这么多阻碍?
- 锁分类: 全局锁, 表级锁 和 行锁.
    - 全局锁: 多整个数据库实例加锁, Flush tables with read lock(FTWRL): 只读. 一下语句会被阻塞.
        - 数据更新语句(增删改)
        - 数据定义语句(包括建表, 修改表结构)
        - 更新类事务的提交语句.
        - 全局锁的使用场景: 全库逻辑备份.
            - 让整个库只读:
                - 主库做备份, 备份期间都不能更新, 业务基本就得停摆.
                - 从库做备份, 备份期间不能执行主库同步过来的binlog, 会导致主从延迟.
            - 在可重复读隔离级别下开启一个事务:
                - mysqldump使用参数-single-transaction的时候,导入数据之前就会启动一个事务,来确保拿到一致性视图, 而由于MVCC的支持, 这个过程中数据是可以正常更新的.
                - 对于引擎不支持这个隔离级别, 比如MyISAM这种不支持事务的引擎, 只能获得最新的数据, 这时我们就需要使用FTWRL命令了.
            - set global readonly=true 和 FTWRL的方式对比:
                - 修改global变量的方式影响面更大的
                - 如果客户端异常断开, FTWRL命令也会自动释放全局锁, 而readonly之后, 数据库会一直保持readonly状态, 这样做会导致整个库长时间处于不可写入状态, 风险高.
    - 表级锁: 表锁/元数据锁
        - 表锁: lock tables ... read/write
        - MDL(meta data lock, version 5.5): 不需要显示的加上, 访问一个表的时候会自动加上.
        - 表级锁可能出现的问题: 小表导致的大问题
            - 事务中的MDL锁, 在语句执行开始时申请, 但是语句结束后并不会马上释放, 而是会等到整个事务提交后再释放. [MDL锁会形成一个队列, 队列中写锁的优先级高于读锁](https://blog.csdn.net/q2878948/article/details/96430129) 之后所有对表的增删改查操作都需要先申请MDL读锁,这样就导致这个表现在完全不可读写了.
            -  场景题: 如果你要变更的表是一个热点表,虽然数据量不大,但是上面的请求很频繁,而你又不得不加一个字段,你该怎么做?
                - kill命令可能未必管用. 理想的方式就是, 在alter table语句里面设定等待时间, 如果在这个等待时间内可以拿到这个MDL写锁最好, 拿不到也不要阻塞后面的业务语句, 先放弃。之后开发人员或者DBA再通过重试命令重复这个过程.
                - MariaDB已经合并了AliSQL的这个功能, 所以这两个开源分支目前都支持DDL
                    - NOWAIT/WAIT n这个语法:
                    - `` ALTER TABLE tbl_name NOWAIT add column...  ``
                    - `` ALTER TABLE tbl_name WAIT N add column...  ``
                - 如果存在lock tables这样的语句, 可能的情况是:
                    - 要么系统现在还在用MyISAM这类不支持事务的引擎, 那么安排升级换引擎
                    - 要么是引擎升级了, 但是代码没有升级, 直接把lock tables 和 unlock tables 改成begin 和 commit, 问题就解决了.
    - 行锁: InnoDB中, 需要的时候再加上, 等到事务结束后释放.
        - 不是所有的引擎都支持行锁, MyISAM不支持行锁, 不支持行锁就意味着并发控制只能使用表锁, 对于这种引擎的表, 同一张表上任何时刻只能有一个更新在执行, 这就会影响业务并发度.
        - 两阶段锁: 
            - 虽然是行锁, 但是要等到 事务commit之后才能释放锁, 不是执行完一行后就释放一个锁.
            - 所以, 如果事务中需要锁多个行 要把最可能造成锁冲突, 最可能影响并发度的锁尽量往后放.
        - 经典场景: 1.顾客A账户余额中扣除电影票价, 2.给影院B的账户余额增加这张电影票价, 3.记录一条交易日志
            - 如果有一个顾客C要在影院B买票, 那么这两个事务冲突的部分就是语句2了
            - 如果把 语句2 安排在最后, 比如: 3, 1, 2的顺序, 那么影院账户余额这一行的锁时间就最少
            - 如果这个影院做活动, 可以低价预售一年内所有的电影票, 而且活动只做一天。于是在活动时间开始的时候, 你的MySQL就挂了, 你登上服务器一看, CPU消耗接近100%, 但是数据库每秒执行不到100个事务, 这是什么原因呢? --> 死锁, 循环依赖的问题.
    - 死锁和死锁检测: 
        - 方法一: 发现死锁后, 直接进入等待, 直到超时(超时时间可以通过innodb_lock_wait_timeout来设置). InnoDB中时间默认值是50s,所以如果采用第一个策略, 出现死锁后, 其他线程需要50s之后才能继续执行(对于在线服务这是无法接受的). 但是如果时间过短也是很容易造成误伤(简单的锁等待)。
        - 方法二: 发起死锁检测: 发现死锁后, 主动回滚死锁链条中的某个事务, 让其他事务得以继续执行, 将参数innodb_deadlock_detect设置为on, 表示开启这个逻辑.(死锁检测需要消耗大量CPU资源.)
            - 如果是像上面的问题, 所有的事务都需要更新同一个行的场景, 每次都需要检测死锁, 一次O(n), 所有的O(n^2), 因此你会看到CPU利用率很高, 但是每秒却执行不了几个事务. 
        - 方法三: 确保业务不会出现死锁, 可以临时把死锁检测关闭. (有风险！) 出现死锁, 就回滚, 然后通过业务重试一般没有问题, 业务无损的; 而关闭死锁检测意味着可能会出现大量的超时, 这是业务有损的.
        - 方法四: 控制并发度, 客户端控制(如果客户端过多, 600*5也有3000), 在消息中间件控制, 如果懂得sql源码, 在源码段控制; 基本思路就是对于相同行的更新, 在进入引擎之前排队, 这样InnoDB内部就不会有大量的死锁检测工作了.
```C++
// 备份一般都会在备库上执行, 你在用-single-transaction方法做逻辑备份的过程中, 如果主库的一个小表做了DDL, // 比如给一个表加上一列, 这时从备库上会看到什么现象呢?
Q1: SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; // 确保RR级别, 再次设置一次
Q2: START TRANSACTION WITH CONSISTENT SNAPSHOT; // 确保这个语句执行完就可以得到一个一致性视图
// other tables
Q3: SAVEPOINT sp; // 保存点, 便于回滚
// 若时刻1到达: 没有现象, 备份拿到的是DDL后的表结构
Q4: show create table 't1'; // show create拿到表结构
// 若时刻2到达: 表结构被改过, Q5执行的时候, 报出Table definition has changed, please retry transaction,
// 现象: mysqldump终止
Q5: SELECT * FROM 't1'; // 导入数据
// 若s时刻2 和 时刻3到达: mysqldump占着t1的MDL读锁, binlog被阻塞,
// 现象: 主从延迟, 知道Q6执行完成.
Q6: ROLLBACK TO SAVEPOINT sp; // 回滚到SAVEPOINT sp;
// 若时刻4到达: mysqldump释放了MDL读锁; 现象: 没有影响, 备份拿到的是DDL前的表结构.
// other tables
```

```C++
// 问题: 如果你要删除一个表里面的前10000行数据, 有一下三种方法可以做到:
// 第一种: 直接执行 delete from T limit 10000;
// 第二种: 在一个连接中循环执行20次 delete from T limit 500;
// 第三种: 在20个链接中同时执行delete from T limit 500;
```
