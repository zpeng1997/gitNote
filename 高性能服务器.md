# 第一章

### 1.多线程下对象的创建
- 不要在构造函数中注册任何回调
+ 不要在构造函数中把this传给跨线程的对象(可使用二段式构造)
* 即使在构造函数的最后一行也不行(基类构造后会构造子类)

### 2.销毁很难
```C++
// foo.cpp
Foo::~Foo()
{
    MutexLOckGuard lock(mutex_); 
    // free internal state ............(1)
}
void Foo::update()
{
    MutexLockGuard lock(mutex_);  //......(2)
    // make use of internal state
}

// other.cpp
extern Foo* x; // visible by all threads;
// thread A
delete x;
x = nullptr; // helpless

// thread B
if(x){
    x->update();
}
// 可能性: thread A 得到了互斥锁后
// thread B 通过 if(x) 检测, 阻塞在(2)处
// 之后可能thread B一直阻塞, 或者进入临界区后core dump, 也可能是其它的现象
```
### 3. 作为数据成员的mutex不能保护析构
+ MutexLock成员最多与对象的生命周期一样长(栈对象而不是堆对象), 但是析构动作可以说是发生在对象身故后.
- 对于基类对象, 调用到基类析构函数的时候, 派生类已经析构, 基类对象的Mutex不能保护整个析构过程
* 最好的避免方法就是当别的线程都访问不到这个对象时, 析构才是安全的。
- 另外, 如果要读一个class的两个对象, 有可能发生死锁: 例如swap 和 operator=()函数
```C++
void swap(Counter& a, Counter& b)
{
    MutexLockGuard aLock(a.mutex_);
    MutexLockGuard bLock(b.mutex_);
    int64_t value = a.value_;
    a.value_ = b.value_;
    b.value_ = value; 
}
Counter& Counter::operator=(Const Counter& rhs)
{
    if(this == &rhs)
        return *this;
    
    MutexLockGuard mylock(mutex_);
    MutexLockGuard itslock(rhs.mutex_);
    value_ = rhs.valuel_;
    return *this;   
}
// 如果一个函数要锁住相同类型的多个对象, 为了保证始终按照相同顺序加锁
// 可以比较mutex对象的地址, 始终先加锁地址比较小的mutex.
```
### 4.线程安全的Observer实现难度
- 对象关系: composition(组合,成员变量,可以控制生命周期), aggregation(聚合,b有a的指针或引用,不可控制生命周期), asscoiation(a与b有整体和部分的关系,其它和aggregation相同;若b动态创建,并且可能在程序结束前释放,就会出现race condition):
    - 山寨解决方案: 只创建不销毁, 构建对象池, 重复利用对象, 用完放回池中, 没用完则新建.
        + 问题一: 对象池的线程安全: 如何安全, 完整的把对象放回池中, 防止“部分放回”的race condition(thread A认为已经放回, thread B认为没有)
        + 问题二: *全局共享数据的lock contention, 集中化的对象池会不会把多线程并发操作串行化。* Lock contention对系统性能影响很大。
        + 问题三: 若共享对象不止一种, 是重复实现对象池还是使用类模板.
        + 问题四: 会不会造成, 内存泄露和分片, 因为对象池占用的内存只增不减, 且多个对象池不可以共享内存.
- 若x注册了任何非静态的回调函数, 必然在某处持有指向x的指针, 从而处于race condition